Dart Functions 

Learn more: https://dart.dev/language/collections

This code comprehensively illustrates how functions are defined, configured with parameters, and utilized as first-class objects in Dart. Functions are the building blocks of application logic.

Basic Function Definition

A traditional function definition specifies the return type and the parameter types.

Structure: ReturnType functionName(ParameterType parameterName) { ... }

Example: The fibonacci function uses type annotations (int) for clarity and readability. This function also demonstrates recursion (a function calling itself).

Arrow Functions (Shorthand)

Dart provides a concise syntax for functions that contain only a single expression.

Syntax: ReturnType functionName(params) => expression;

Behavior: The => (arrow) syntax is shorthand for { return expression; }. It is perfect for simple operations like the square function.

Function Parameters

Dart offers great flexibility in defining how parameters are passed to a function, enhancing clarity and preventing errors.

Optional Positional Parameters: Parameters enclosed in square brackets ([]) are optional. If they are nullable (like String? device), they will be null if not provided.
Example: say(String from, String msg, [String? device])

Default Parameter Values: You can assign default values to optional parameters. If the caller omits the parameter, the default value is used.
Example: greet(String name, [String greeting = 'Hello'])

Named Parameters: Parameters enclosed in curly braces ({}) must be referenced by their name when the function is called, improving call site clarity.

required: The required keyword ensures that the caller must provide a value for that named parameter (name in the example).

Default Value: Named parameters can also have default values (age = 0) and be nullable (String? city).

Functions as First-Class Objects

In Dart, functions are objects, meaning they can be treated like any other value.

Assigned to Variables: A function (even an anonymous one) can be assigned to a variable, which can then be called like a regular function.
Example: var multiply = (int a, int b) => a * b;

Anonymous Functions (Closures): A function without a name. They are commonly used when iterating over collections, such as within the forEach method.

Closures can access variables from the scope they are defined in.

They can be written using either block syntax or the concise arrow syntax.

Functions as Parameters: A function can be passed as an argument to another function, enabling powerful higher-order programming patterns.
Example: executeOperation(10, 5, (a, b) => a + b) passes an anonymous addition function.